using System.Collections.Immutable;
using System.Diagnostics;
using Ink.Blocks;
using Ink.Blocks.State;
using Ink.Math;
using Ink.SourceGenerator.Util;

namespace Ink.SourceGenerator.Block;

public sealed class PropertyStore
{
    private readonly Dictionary<string, List<Property>> namedProperties = new();

    public void WriteTo(IndentingStringBuilder builder)
    {
        builder.WriteLine($$"""
                // <auto-generated />
                using Ink.Blocks;
                using Ink.Math;
                using static Ink.Math.Direction;

                namespace Ink.Blocks.State;

                public static class Properties
                """); 

        using(builder.EnterBlock())
        {
            foreach((string name, List<Property> properties) in this.namedProperties.OrderBy(static kv => kv.Key, StringComparer.InvariantCultureIgnoreCase))
            {
                if(properties.Count == 1)
                {
                    builder.Write($"public static readonly Property {Generation.ToPascalCase(name)} = ");
                    WritePropertyTo(builder, properties[0]);
                    builder.WriteLine(";");
                    continue;
                }

                // We need to add a suffix...
                for(int i = 0; i < properties.Count; ++i)
                {
                    Property property = properties[i];
                    builder.Write($"public static readonly Property {GetUniquePropertyName(name, property)} = ");         
                    WritePropertyTo(builder, property);
                    builder.WriteLine(";");
                }
            }
        }
    }

    private static void WritePropertyTo(IndentingStringBuilder builder, Property property)
    {
        switch(property)
        {
            case BoolProperty: 
                {
                    builder.Write("BoolProperty.Shared");
                    break;
                }
            case Int32Property i32: 
                {
                    builder.Write($"new Int32Property({i32.Min}, {i32.Max})");
                    break;
                }
            case EnumProperty e:
                {
                    builder.Write($"EnumProperty<{e.Enum.Name}>.From([");
                    
                    int current = 0;
                    foreach(int rawValue in e.DefinedValues)
                    {
                        builder.Write($"{e.Enum.Name}.{Enum.GetName(e.Enum, rawValue)}");

                        if(++current != e.PossibleValues)
                            builder.Write(", ");
                    }

                    builder.Write("])");
                    break;
                }
        }
    }

    public Property GetProperty(string name, int index)
        => this.namedProperties[name][index];

    public string GetName(string name, int index)
    {
        List<Property> properties = this.namedProperties[name];

        if(properties.Count == 1)
            return Generation.ToPascalCase(name);

        return GetUniquePropertyName(name, properties[index]);
    }

    public int Add(string name, ImmutableArray<string> values)
    {
        if(!namedProperties.TryGetValue(name, out List<Property>? properties))
        {
            properties = new();
            namedProperties.Add(name, properties);
        }

        int propertyIndex = TryGetOrAdd(name, properties, values);
        return propertyIndex;
    }

    private int TryGetOrAdd(string name, List<Property> properties, ImmutableArray<string> values)
    {
        if(values.Length == 2 && values[0] == "true" && values[1] == "false")
        {
            int index = properties.IndexOf(BoolProperty.Shared);
            if(index == -1)
            {
                properties.Add(BoolProperty.Shared);
                index = properties.Count - 1;
            }

            return index;
        }
        
        if(int.TryParse(values[0], out int initial)) // Assume it is an integer directly...
        {
            int min = initial;
            int max = initial;

            for(int i = 1; i < values.Length; ++i)
            {
                int current = int.Parse(values[i]);

                if(current < min)
                {
                    min = current;
                }
                else if(current > max)
                {
                    max = current;
                }
            }

            int foundProperty = properties.FindIndex(0, p => p is Int32Property int32 && int32.Min == min && int32.Max == max);

            if(foundProperty == -1)
            {
                properties.Add(new Int32Property(min, max));
                foundProperty = properties.Count - 1;
            }

            return foundProperty;
        }

        // HACK: Maybe move this to an array and a loop? We don't need *that* much performance here...
        if(TryParseEnum<Direction.Directions>(name, properties, values, out int foundIndex))
            return foundIndex;

        if(TryParseEnum<Direction.Axes>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<ButtonBlockAttachment>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<SlabBlockType>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<ButtonBlockAttachment>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<TallBlockPart>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<WallBlockConnection>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<NoteBlockInstrument>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<StairsBlockShape>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<DoorBlockHinge>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<RedstoneWireBlockAttachment>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<BedBlockPart>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<PistonBlockType>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<SculkSensorBlockPhase>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<ChestBlockType>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<RailBlockShape>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<TrialSpawnerBlockState>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<StructureBlockMode>(name, properties, values, out foundIndex))
            return foundIndex;
        
        if(TryParseEnum<BellBlockAttachment>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<VaultBlockState>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<ComparatorBlockMode>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<DripleafBlockTilt>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<PointerDripstoneBlockThickness>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<BambooBlockLeaves>(name, properties, values, out foundIndex))
            return foundIndex;

        if(TryParseEnum<BlockOrientation>(name, properties, values, out foundIndex))
            return foundIndex;


        throw new NotImplementedException($"Enum(?) not implemented, values: {string.Join('|', values)}");
    }

    // HACK: Big, big hack to convert the string to pascalcase
    private bool TryParseEnum<TEnum>(string name, List<Property> properties, ImmutableArray<string> values, out int foundIndex)
        where TEnum : unmanaged, Enum
    {
        if(!Enum.TryParse(Generation.ToPascalCase(values[0]), true, out TEnum e))
        {
            foundIndex = default;
            return false;
        }

        TEnum[] possibleDirections = new TEnum[values.Length];
        possibleDirections[0] = e;

        for(int i = 1; i < values.Length; ++i)
        {
            if(!Enum.TryParse(Generation.ToPascalCase(values[i]), true, out possibleDirections[i]))
            {
                foundIndex = default;
                return false;
            }
        }
        
        foundIndex = properties.FindIndex(0, p => p is EnumProperty<TEnum> e && e.Values.SequenceEqual(possibleDirections));

        if(foundIndex == -1)
        {
            properties.Add(EnumProperty<TEnum>.From(possibleDirections));
            foundIndex = properties.Count - 1;
        }

        return true;
    }

    private static string GetUniquePropertyName(string name, Property property)
        => $"{Generation.ToPascalCase(name)}{(property switch {
            BoolProperty => "Bool",
            Int32Property i32 => $"{i32.Min}To{i32.Max}",
            EnumProperty e => $"{e.Enum.Name}With{e.PossibleValues}Values",
            _ => throw new UnreachableException()
        })}";
}
