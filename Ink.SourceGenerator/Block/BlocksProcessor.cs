using System.CodeDom.Compiler;
using System.Collections.Immutable;

namespace Ink.SourceGenerator.Block;

public static class BlocksProcessor // TODO: Refactor this some day, make it a netstandard2.0 C# SourceGenerator?
{
    const string Namespace = "Ink.Blocks.State";
    const string ClassName = "BlockStates";

    public static void WriteTo(IndentedTextWriter writer, ImmutableDictionary<string, BlockData> blocks)
    {
        SharedPropertyDefinitionStore propertyStore = new();
        SharedPropertyValueStore propertyValueStore = new();

        writer.WrtLine("// <auto-generated />")
              .WrtLine("using System.Collections.Frozen;")
              .WrtLine("using System.Collections.Immutable;")
              .WrtLine("using System.Runtime.InteropServices;")
              .WrtLine("using Ink.Registries;")
              .WrtLine("using Ink.Util;")
              .WrtLine()
              .WrtLine($"namespace {Namespace};")
              .WrtLine()
              .WrtLine($"public static partial class {ClassName}")
              .WrtLine('{')
              .Ind();

        WriteStaticConstructor(writer, blocks);
        writer.WriteLine();
        foreach (var block in blocks)
            WriteTo(writer, propertyStore, propertyValueStore, block.Key, block.Value);

        writer.WriteLine();
        propertyStore.WriteTo(writer);
        writer.WriteLine();
        propertyValueStore.WriteTo(writer);
        writer.WriteLine();

        writer.Unind()
              .WrtLine('}');
    }

    private static void WriteTo(IndentedTextWriter writer, SharedPropertyDefinitionStore store, SharedPropertyValueStore valueStore, string blockIdentifier, BlockData data)
    {
        (string indexName, string definitionsName) = store.GetOrAddPropertyDefinitions(data.Properties);
        writer.WrtLine($"public static partial class {Generation.ToPascalCase(blockIdentifier)}")
              .WrtLine('{')
              .Ind();

        writer.Wrt($"public static readonly BlockStateRoot Root = new(Identifier.Vanilla(\"{blockIdentifier.AsSpan()["minecraft:".Length..]}\"), {indexName}, {definitionsName}, ");
        WriteBlockStates(writer, valueStore, data);
        writer.WrtLine(");");

        writer.Unind()
              .WrtLine('}')
              .WrtLine();
    }

    private static void WriteBlockStates(IndentedTextWriter writer, SharedPropertyValueStore valueStore, BlockData data)
    {
        int current = 0;
        ImmutableArray<DefinedBlockState> states = data.States;
        foreach (var state in states)
        {
            WriteBlockStateDefinition(writer, valueStore, state, data);

            if (++current < states.Length)
                writer.Wrt(", ");
        }
    }

    private static void WriteBlockStateDefinition(IndentedTextWriter writer, SharedPropertyValueStore valueStore, DefinedBlockState state, BlockData data)
        => writer.Wrt($"new BlockStateDefinition({valueStore.GetOrAddPropertyValues(state.Properties, data.Properties)}, {state.Id}, {(state.IsDefault ? "true" : "false")})");

    private static void WriteStaticConstructor(IndentedTextWriter writer, ImmutableDictionary<string, BlockData> blocks)
    {
        const string BaseDictionaryName = "tmpDictionary";

        writer.WrtLine($"static {ClassName}()")
              .WrtLine('{')
              .Ind()
              .WrtLine($"Dictionary<int, (BlockStateRoot, int)> {BaseDictionaryName} = new();");

        foreach (var block in blocks)
            writer.WriteLine($"AddRoot({BaseDictionaryName}, {Generation.ToPascalCase(block.Key)}.Root);");

        writer.WrtLine($"AllStates = tmpDictionary.ToFrozenDictionary();")
              .WrtLine($"StateCount = AllStates.Count;")
              .WrtLine($"MaxStateBits = Utilities.BitSize(StateCount);")
              .Unind()
              .WrtLine('}');
    }
}
