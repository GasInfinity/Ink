using System.Collections.Immutable;
using Ink.SourceGenerator.Util;

namespace Ink.SourceGenerator.Packet;

// TODO: Someday... Refactor this... again... yes... more...
public static class PacketProcessor
{
    private static readonly PacketSide[] SideValues = PacketSideExtensions.GetValues();
    private const string OutputPrefix = "Out/Net/Generated/";
    
    private static string GetPacketName(PacketSide side, Identifier location, PacketData? data)
        => !string.IsNullOrEmpty(data?.Name) ? data.Value.Name : Generation.ToPascalCase($"{side}_{location.Path}");

    public static void Process(ImmutableDictionary<PacketKind, ImmutableDictionary<PacketSide, ImmutableDictionary<string, PacketDefinition>>> packets, ImmutableDictionary<PacketKind, ImmutableDictionary<PacketSide, ImmutableDictionary<string, PacketData?>>> packetsData)
    {
        ProcessPacketData(packetsData);
        ProcessPacketInfo(packetsData);
        ProcessNetworkStatePackets(packets, packetsData);
    }
    
    private static void ProcessNetworkStatePackets(ImmutableDictionary<PacketKind, ImmutableDictionary<PacketSide, ImmutableDictionary<string, PacketDefinition>>> packets, ImmutableDictionary<PacketKind, ImmutableDictionary<PacketSide, ImmutableDictionary<string, PacketData?>>> packetsData)
    {
        foreach((PacketKind kind, ImmutableDictionary<PacketSide, ImmutableDictionary<string, PacketDefinition>> kindData) in packets)
        {
            string fullPath = Path.Join(OutputPrefix, $"{kind}StateInfo.g.cs");

            IndentingStringBuilder builder = new();
            builder.WriteLine(true, $$"""
                    // <auto-generated />
                    #nullable enable

                    using Ink.Registries;

                    namespace Ink.Net;

                    public partial class NetworkStates
                    """);
            using(builder.EnterBlock())
            {
                builder.Write(true, $"public static readonly NetworkStateInfo {kind}StateInfo = new(");
                using(builder.EnterIndentedRegion())
                {
                    int i = 0;
                    foreach(PacketSide side in SideValues)
                    {
                        if(!kindData.TryGetValue(side, out ImmutableDictionary<string, PacketDefinition>? definitions))
                        {
                            builder.Write($"{side}: FrozenRegistry<IPacketInfo>.Empty"); 
                        }
                        else
                        {
                            ImmutableDictionary<string, PacketData?> commonPacketData = packetsData[PacketKind.Common][side];
                            ImmutableDictionary<string, PacketData?> kindPacketData = packetsData[kind][side];

                            builder.WriteLine($"{side}: new FrozenRegistryBuilder<IPacketInfo>()");
                            foreach((string key, PacketDefinition definition) in definitions)
                            {
                                Identifier keyIdentifier = Identifier.Parse(key, null);

                                if(!kindPacketData.TryGetValue(keyIdentifier.Path, out PacketData? packet) && 
                                   !kindPacketData.TryGetValue(keyIdentifier.ToString(), out packet))
                                {
                                    throw new InvalidDataException($"Found key {keyIdentifier.ToString()} which doesnt have matching packet data. Kind: {kind} | Side: {side}"); 
                                }

                                if(!packet.HasValue && 
                                   !commonPacketData.TryGetValue(keyIdentifier.Path, out packet) && 
                                   !commonPacketData.TryGetValue(keyIdentifier.ToString(), out packet))
                                {
                                    throw new InvalidDataException($"Found key {keyIdentifier.ToString()} whose common packet does not exist. Kind: {kind} | Side: {side}");
                                }
                                
                                string className = GetPacketName(side, keyIdentifier, packet);
                                builder.WriteLine($".Register({definition.ProtocolId}, {kind}Packets.{className}Info)"); 
                            }
                            builder.Write(".Freeze()");
                        }

                        if(++i != PacketSideExtensions.Length)
                            builder.WriteLine(",");
                    }
                }
                builder.WriteLine(");");
            }

            File.WriteAllText(fullPath, builder.ToString());
        } 
    }

    private static void ProcessPacketInfo(ImmutableDictionary<PacketKind, ImmutableDictionary<PacketSide, ImmutableDictionary<string, PacketData?>>> packetsData)
    {
        foreach((PacketKind kind, ImmutableDictionary<PacketSide, ImmutableDictionary<string, PacketData?>> kindData) in packetsData)
        {
            string fullPath = Path.Join(OutputPrefix, $"{kind}Packets.g.cs");

            IndentingStringBuilder builder = new();
            builder.WriteLine(true, $$"""
                    // <auto-generated />
                    #nullable enable

                    using Ink.Registries;
                    {{(kind != PacketKind.Common ? "using Ink.Net.Packets.Common;" : string.Empty)}}
                    using Ink.Net.Packets.{{kind}};

                    namespace Ink.Net;

                    public static class {{kind}}Packets
                    """);
            using(builder.EnterBlock())
            {
                foreach((PacketSide side, ImmutableDictionary<string, PacketData?> packets) in kindData)
                {
                    foreach((string key, PacketData? possibleData) in packets)
                    {
                        Identifier keyIdentifier = Identifier.Parse(key, null);
                        
                        string className = GetPacketName(side, keyIdentifier, possibleData);
                        builder.WriteLine($"public static readonly PacketInfo<{className}> {className}Info = {(possibleData.HasValue ? "new()" : $"CommonPackets.{className}Info")};");
                    }
                }
            }

            File.WriteAllText(fullPath, builder.ToString());
        }
    }

    private static void ProcessPacketData(ImmutableDictionary<PacketKind, ImmutableDictionary<PacketSide, ImmutableDictionary<string, PacketData?>>> packetsData)
    {
        foreach((PacketKind kind, ImmutableDictionary<PacketSide, ImmutableDictionary<string, PacketData?>> kindData) in packetsData)
        {
            _ = Directory.CreateDirectory(Path.Join(OutputPrefix, $"Packets/{kind}"));

            foreach((PacketSide side, ImmutableDictionary<string, PacketData?> packets) in kindData)
            {
                foreach((string key, PacketData? possibleData) in packets)
                {
                    if(possibleData is not PacketData data)
                        continue;

                    Identifier keyIdentifier = Identifier.Parse(key, null);

                    PacketProcessor.WriteData(kind, side, keyIdentifier, data);
                }
            }
        }
    }

    public static void WriteData(PacketKind kind, PacketSide side, Identifier location, PacketData data)
    {
        string @namespace = $"Ink.Net.Packets.{kind}";
        string className = GetPacketName(side, location, data);
        string finalPath = Path.Join(OutputPrefix, $"Packets/{kind}/{className}.g.cs");

        IndentingStringBuilder builder = new();

        OrderedDictionary<string, IPacketFieldType>? fields = data.Fields;

        builder.WriteLine("""
                // <auto-generated />
                #nullable enable
                """);

        if(fields == null)
        {
            builder.WriteLine($$"""
                    using Ink.Registries;
                    using System.Buffers;

                    namespace {{@namespace}};

                    public readonly record struct {{className}} : IPacket<{{className}}>
                    {
                        public static Identifier PacketLocation => Identifier.Vanilla("{{location.Path}}");
                        public static NetworkDirection PacketDirection => NetworkDirection.{{side}};

                        public void Write(IBufferWriter<byte> writer)
                        { }

                        public static bool TryRead(ReadOnlySpan<byte> payload, out {{className}} result)
                        {
                            result = default;
                            return true;
                        }
                    }
                    """);

            File.WriteAllText(finalPath, builder.ToString());
            return;
        }

        builder.Write(true, $$"""
                using Ink.Auth;
                using Ink.Text;
                using Ink.Chat;
                using Ink.Math;
                using Ink.Items;
                using Ink.Worlds;
                using Ink.Resources;
                using Ink.Nbt.Tags;
                using Ink.Registries;
                using Ink.Entities;
                using Ink.Util;
                using Ink.Util.Extensions;
                using Ink.Net.Structures;
                using Rena.Native.Buffers.Extensions;
                using System.Buffers;
                using System.Buffers.Binary;
                using System.Collections.Immutable;
                using System.Runtime.InteropServices;
                using System.Runtime.CompilerServices;
                using System.Text.Json;

                namespace {{@namespace}};

                public readonly record struct {{className}}(
                """);

        {
            int i = 0;
            foreach((string fieldName, IPacketFieldType fieldType) in fields)
            {
                fieldType.AppendTypename(builder);
                builder.Write($" {fieldName}");

                if (++i != fields.Count)
                    builder.Write(", ");
            }
        }

        builder.WriteLine(true, $$"""
                ) : IPacket<{{className}}>
                """);
        using(builder.EnterBlock())
        {
            builder.WriteLine(true, $$"""
                    public static Identifier PacketLocation => Identifier.Vanilla("{{location.Path}}");
                    public static NetworkDirection PacketDirection => NetworkDirection.{{side}};

                    """);

            foreach((string fieldName, IPacketFieldType fieldType) in fields)
            {
                builder.Write($"public readonly ");
                fieldType.AppendTypename(builder);
                builder.WriteLine($" {fieldName} = {fieldName};");
            }

            builder.WriteLine(true, $$"""

                    public void Write(IBufferWriter<byte> writer)
                    """);
            using (builder.EnterBlock())
            {
                foreach((string fieldName, IPacketFieldType fieldType) in fields)
                {
                    fieldType.AppendWriting(builder, fieldName);
                }
            }

            builder.WriteLine(true, $$"""

                    public static bool TryRead(ReadOnlySpan<byte> payload, out {{className}} result)
                    """);
            using(builder.EnterBlock())
            {
                foreach((string fieldName, IPacketFieldType fieldType) in fields)
                {
                    fieldType.AppendTypename(builder);
                    builder.WriteLine($" {fieldName};");
                    
                    fieldType.AppendReading(builder, fieldName);
                }

                builder.Write("result = new(");

                int i = 0;
                foreach((string fieldName, IPacketFieldType fieldType) in fields)
                {
                    builder.Write(fieldName);

                    if (++i != fields.Count)
                        builder.Write(", ");
                }

                builder.WriteLine("""
                        );
                        return true;
                        """, true);
            }
        }

        File.WriteAllText(finalPath, builder.ToString());
    }
}
